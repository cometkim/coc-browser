const { sources, workspace } = require('coc.nvim')
const http = require('http')
const fs = require('fs')
const readline = require('readline')
const util = require('util')

const DICT_CACHE = {}
let FILE_COUNT = 5
let COUNTER = 0

exports.activate = async context => {
  let config = workspace.getConfiguration('coc.browser')
  let enable = config.get('enable', true)

  if (!enable) {
    return
  }

  let shortcut = config.get('shortcut', 'web')
  let priority = config.get('priority', 50)
  let capacity = config.get('capacity', 3)
  if (capacity > 0 && capacity <= 10) {
    FILE_COUNT = capacity
  }
  let source = {
    name: 'browser',
    shortcut: shortcut,
    priority: priority,
    triggerCharacters: [],
    doComplete: async function(opt) {
      let wordsFile = []
      for (let i = 0; i < FILE_COUNT; i++) {
        let file = `${__dirname}/source/words_${i}.txt`
        if (fs.existsSync(file)) {
          wordsFile.push(file)
        }
      }
      let words = await getWords(wordsFile)
      words = filterWords(words, opt)
      return {
        items: words.map(word => {
          return {
            word,
            menu: this.menu
          }
        })
      }
    }
  }
  context.subscriptions.push(sources.createSource(source))
}

function readFileByLine(file, limit = 300000) {
  const set = new Set()
  const rl = readline.createInterface({
    input: fs.createReadStream(file),
    crlfDelay: Infinity,
    terminal: false,
    highWaterMark: 1024 * 1024
  })
  let n = 0
  rl.on('line', line => {
    n = n + 1
    if (n === limit) {
      rl.close()
    } else if (line.length > 0) {
      let words = line.split(/\s+/)
      for (let word of words) {
        if (word.length > 1) set.add(word)
      }
    }
  })
  return new Promise((resolve, reject) => {
    rl.on('close', () => {
      resolve(set)
    })
    rl.on('error', reject)
  })
}

async function getDictWords(file) {
  try {
    let stat = await util.promisify(fs.stat)(file)
    if (!stat || !stat.isFile()) return null
    let cache = DICT_CACHE[file]
    if (cache && cache.mtime == stat.mtime) {
      return cache.words
    }
    let words = await readFileByLine(file)
    DICT_CACHE[file] = { mtime: stat.mtime, words }
    return words
  } catch (e) {
    console.error(e)
  }
  return []
}

async function getWords(files) {
  if (files.length == 0) return []
  let arr = await Promise.all(files.map(file => getDictWords(file)))
  let res = new Set()
  for (let words of arr) {
    if (words == null) continue
    for (let word of words) {
      if (!res.has(word)) res.add(word)
    }
  }
  return Array.from(res)
}

function filterWords(words, opt) {
  let res = []
  let { input } = opt
  for (let word of words) {
    if (!word.startsWith(input[0])) continue
    if (word.length <= input.length) continue
    res.push(word)
  }
  return res
}

;(function startServer() {
  let server = new http.Server()
  server.listen(8888)
  // if there is already a server running on the port
  // then close this server and use the words file generated by another server
  server.once('error', () => {
    server.close()
  })
  server.once('listening', () => {
    // todo: write to CocInfo
  })
  server.on('request', (request, response) => {
    let words = ''
    request.on('data', data => {
      words += data
    })
    request.on('end', () => {
      saveWords(words)
    })
    request.on('error', e => {
      workspace.showMessage(`request error from browser: ${e.message}`)
    })
    response.writeHead(200, { 'Content-Type': 'text/plain' })
    response.write('response from coc-browser local server\n')
    response.end()
  })
})()

function saveWords(text) {
  let sourceDir = `${__dirname}/source`
  if (!fs.existsSync(sourceDir)) {
    fs.mkdirSync(sourceDir)
  }
  fs.writeFile(`${sourceDir}/words_${COUNTER % FILE_COUNT}.txt`, text, err => {
    if (err) {
      workspace.showMessage(err)
      return
    }
  })
  COUNTER++
}
